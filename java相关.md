###  一、面向对象相关

###### 1、面向对象三大特征

> 1、封装：通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。
>
> 2、继承：继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）。
>
> 3、多态：多态顾名思义“一种形式多种状态”说了等于白说。其实啥叫多态呢？或许可以这样说：子类对象持有父类或者接口类型的引用，在方法调用期间动态的改变。
>
> [ps：参考文章1](https://blog.csdn.net/qq_38350635/article/details/101204524)
>
> [ps:参考文章2](https://www.jianshu.com/p/f78cab5deb9a)

###### 2、多态相关

> 多态分类：
>
> 1、编译时多态：方法重载
> 2、运行时多态：方法重写(方法覆盖)
>
> 方法重载：都是编译时多态。因为方法重载发生在一个类中。根据实际参数的数据类型、个数和次序，Java在编译时能够确定执行重载方法中的哪一个。编译期就能确定，所以为编译期多态。
>
> 方法覆盖：表现出两种多态性，当对象引用本类实例时（发生在一个类中例如：Dog dog = new Dog（）；dog调用本类方法。即使这个方法是覆盖父类中的。），为编译时多态，否则为运行时多态（Animal animal = new Dog（） animal 运行时调用dog中覆盖父类中的方法）。
>
>  [ps：方法重写表现为两种多态性。](https://blog.csdn.net/qq_38962004/article/details/79690627)
>
> 多态的作用：
>
> 消除类型之间的耦合关系。
>
> 多态的发生条件：
>
> 1、继承
>
> 2、重写
>
> 3、父类/接口引用指向子类对象
>
> 多态好处：
>
> 1、可替换性（substitutability）。多态对已存在代码具有可替换性。例如，多态对圆Circle类工作，对其他任何圆形几何体，如圆环，也同样工作。
>
> 2、可扩充性（extensibility）。多态对代码具有可扩充性。增加新的子类不影响已存在类的多态性、继承性，以及其他特性的运行和操作。实际上新加子类更容易获得多态功能。例如，在实现了圆锥、半圆锥以及半球体的多态基础上，很容易增添球体类的多态性。
>
> 3、接口性（interface-ability）。多态是超类通过方法签名，向子类提供了一个共同接口，由子类来完善或者覆盖它而实现的。如图8.3 所示。图中超类Shape规定了两个实现多态的接口方法，computeArea()以及computeVolume()。子类，如Circle和Sphere为了实现多态，完善或者覆盖这两个接口方法
>
> 4、活性（flexibility）。它在应用中体现了灵活多样的操作，提高了使用效率。
>
> 5、简化性（simplicity）。多态简化对应用软件的代码编写和修改过程，尤其在处理大量对象的运算和操作时，这个特点尤为突出和重要。

###### 3、抽象类和接口区别

>1、默认的方法实现
>
>抽象类可以有默认的方法实现。接口完全是抽象的，接口根本不存在方法的实现
>
>2、实现
>
>抽象类的子类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方抽象的方法的实现。接口子类使用关键字implements来实现接口。它需要提供接口中所有声明的方法的实现
>
>3、构造器
>
>抽象类可以有构造器，接口不能有构造器。
>
>4、接口中不能定义构造器的理由：
>
>- 构造器用于初始化成员变量，接口没有成员变量
>- 类可以实现多个接口，若多个接口都有自己的构造器，则不好决定构造器链的调用次序
>- 构造器是属于类自己的，不能继承。因为是纯虚的，接口不需要构造器。
>
>5、和正常java类的区别
>
>抽象类除了你不能实例化抽象类之外，它和普通Java类没有任何区。接口是完全不同的类型
>
>6、访问修饰符
>
>抽象方法可以有public、protected和default这些修饰符。接口中方法默认public，你不可以使用其它修饰符。
>
>7、多继承
>
>抽象类在java语言中所表示的是一种继承关系，一个子类只能存在一个父类，但是可以存在多个接口。
>
>8、速度
>
>抽象类它比接口速度要快，接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法。
>
>9、添加新方法
>
>如果你往抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码。如果你往接口中添加方法，那么你必须改变实现该接口的类。

###### 4、父类的静态方法能否被子类重写

> 不能：
>
> 1、静态方法和属性是属于类的，调用的时候直接通过类名.方法名完成对，不需要继承机制及可以调用。如果子类里面定义了静态方法和属性，那么这时候父类的静态方法或属性称之为"隐藏"。如果你想要调用父类的静态方法和属性，直接通过父类名.方法或变量名完成，至于是否继承一说，子类是有继承静态方法和属性，但是跟实例方法和属性不太一样，存在"隐藏"的这种情况。
>
> 2、重写指的是根据运行时对象的类型来决定调用哪个方法，而不是根据编译时的类型。
>
> [答案参考](https://www.jianshu.com/p/15e21428d884)

###### 5、方法重载和方法重写区别

> [答案](https://www.nowcoder.com/questionTerminal/830d1dbe2d1a4481ae4f753d77d2e89a?orderByHotValue=1&page=1&onlyReference=false)

### 二、基础知识相关

1、java中==和equals和hashCode的区别  

> [参考答案1](https://blog.csdn.net/tiantiandjava/article/details/46988461)
>
> [答案2：为啥重写hashCode方法](https://blog.csdn.net/changrj6/article/details/100043822)

###### 2、int、char、long各占多少字节数

> 常见类型所占字节：
>
> byte 1
>
> short 2
>
> char 2
>
> int    4
>
> float  4
>
> long  8
>
> double 8
>
> [boolean](https://www.cnblogs.com/wangtianze/p/6690665.html?utm_source=itdadao&utm_medium=referral)

###### 3、int与integer的区别

> 1、int 是基本类型，直接存数值，而integer是对象，用一个引用指向这个对象
>
> 2、int类型的变量初始为0.而Integer类的变量则初始化为null.
>
> 3、int和Integer不能够互用，因为他们两种不同的数据类型（集合存数据时可以看出）
>
> 4、如果我们定义一个int类型的数，只是用来进行一些加减乘除的运算or作为参数进行传递，那么就可以直接声明为int基本数据类型，但如果要像
>
> 对象一样来进行处理，那么就要用Integer来声明一个对象，因为java是面向对象的语言，因此当声明为对象时能够提供很多对象间转换的方式，与一些常用的方法。自认为java作为一们面向对象的语言，我们在声明一个变量时最好声明为对象格式，这样更有利于你对面向对象的理解
>
> [参考答案](https://www.cnblogs.com/shenliang123/archive/2011/10/27/2226903.html)

###### 4、String、StringBuffer、StringBuilder区别

> 1、String是final类，底层final char数组实现。不可变字符串序列。String的值是不可变的，这就导致每次对String的操作都会生成新的String对象，这样不仅效率低下，而且大量浪费有限的内存空间。
>
> 2、StringBuffer ：可变字符串序列，当对字符串修改时使用，线程安全，由于加了锁，导致效率低。
>
> 3、StringBuild：可变字符串序列，效率高，不能保证线程安全。
>
> ps：总结：StringBuffer 和StringBuild的区别就是StringBuffer 的一些核心方法上加了锁。如果要操作少量的数据用 String；多线程操作字符串缓冲区下操作大量数据 StringBuffer；单线程操作字符串缓冲区下操作大量数据 StringBuilder。



###### 5、泛型中extends和super的区别

> [参考1](https://itimetraveler.github.io/2016/12/27/%E3%80%90Java%E3%80%91%E6%B3%9B%E5%9E%8B%E4%B8%AD%20extends%20%E5%92%8C%20super%20%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F/)
>
> [参考2：本章节的通配符介绍](https://blog.csdn.net/qq_38350635/article/details/96610916)

###### 6、进程和线程的区别

> [答案](https://blog.csdn.net/kuangsonghan/article/details/80674777)

###### 7、final，finally，finalize的区别

> [答案](https://www.cnblogs.com/ktao/p/8586966.html)

###### 8、序列化

> [答案参考](https://blog.csdn.net/qq_38350635/article/details/88925390)

###### 9、闭包和局部内部类的区别

> [答案](https://blog.csdn.net/github_37130188/article/details/94589869)
>
> [ps:闭包参考groovy中的闭包概念理解](https://blog.csdn.net/qq_38350635/article/details/102465216)

###### 10、string 转换成 integer的方式及原理

>[答案](https://www.jianshu.com/p/9eebb4f2ccb1)



### 三、优点难度的

1、垃圾回收机制处理

>1、那些内存需要被回收：垃圾对象回收之前要先进行对象搜索，然后再进行回收。搜索设计到了两个算法：引用计数算法（已启用）、可达性分析算法。
>
>- 虚拟机栈中引用的对象
>- 方法区中静态属性引用的对象
>- 方法区中常量引用的对象
>- 本地方法栈中JNI应用的对象
>
>2、垃圾回收算法
>
>- 标记―清除算法：包括两个阶段：“标记”和“清除”。在标记阶段，确定所有要回收的对象，并做标记。清除阶
>
>  段紧随标记阶段，将标记阶段确定不可用的对象清除。标记―清除算法是基础的收集算法，标记和清除阶段的效率不高，而且清除后回产生大量的不连续空间，这样当程序需要分配大内存对象时，可能无法找到足够的连续空间。
>
>- 复制算法：复制算法是把内存分成大小相等的两块，每次使用其中一块，当垃圾回收的时候，把存活的对象复制到另一块上，然后把这块内存整个清理掉。复制算法实现简单，运行效率高，但是由于每次只能使用其中的一半，造成内存的利用率不高。现在的 JVM 用复制方法收集新生代，由于新生代中大部分对象（98%）都是朝生夕死的，所以两块内存的比例不是 1:1(大概是 8:1)。
>
>- 标记―整理算法：标记―整理算法和标记―清除算法一样，但是标记―整理算法不是把存活对象复制到另一块内存，而是把存活对象往内存的一端移动，然后直接回收边界以外的内存。标记―整理算法提高了内存的利用率，并且它适合在收集对象存活时间较长的老年代。
>
>- 分代收集：分代收集是根据对象的存活时间把内存分为新生代和老年代，根据各个代对象的存活特点，每个代采用不同的垃圾回收算法。新生代采用复制算法，老年代采用标记―整理算法。垃圾算法的实现涉及大量的程序细节，而且不同的虚拟机平台实现的方法也各不相同。

###### 2、常见编码方式

> [答案](https://www.cnblogs.com/mlan/p/7823375.html)
>
> [答案2](https://blog.csdn.net/github_37130188/article/details/95110315)

###### 3、静态代理和动态代理的区别，什么场景使用

> [答案](https://blog.csdn.net/asd051377305/article/details/80490432)

###### 4、Java 中异常分为哪些种类

> 按 照 异 常 需 要 处 理 的 时 机 分 为 :
>
> - 编 译 时 异 常 也 叫 CheckedException 
>
> - 运 行 时 异 常 也 叫RuntimeException。
>
>   ?
>
>   只有 java 语言提供了 Checked 异常，Java 认为 Checked 异常都是可以被处理的异常，所以 Java 程序必须显式处理 Checked 异常。如果程序没有处理 Checked 异常，该程序在编译时就会发生错误无法编译。这体现了 Java 的设计哲学：没有完善错误处理的代码根本没有机会被执行。对 Checked 异常处理方法有两种：1 、当前方法知道如何处理该异常，则用 try...catch 块来处理该异常。
>
>   2 、当前方法不知道如何处理，则在定义该方法是声明抛出该异常。运行时异常只有当代码在运行时才发行的异常，编译时不需要 try catch。Runtime 如除数是 0 和数组下标越界等，其产生频繁，处理麻烦，若显示申明或者捕获将会对程序的可读性和运行效率影响很大。所以由系统自动检测并将它们交给缺省的异常处理程序。当然如果你有处理要求也可以显示捕获它们。

###### 5、谈谈你对解析与分派的认识

> [答案](https://www.jianshu.com/p/44790a602e11)

###### 6、[Java深入源码级面试题](https://segmentfault.com/a/1190000020260377)



### 四、java数据结构相关



### 五、线程相关



###### 未完待续待续。。



 